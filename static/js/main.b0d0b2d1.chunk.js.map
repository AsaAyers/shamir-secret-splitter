{"version":3,"sources":["components/part-page/styles.module.css","components/print/styles.module.css","components/edit/styles.module.css","constants.ts","components/part-input/index.tsx","components/part-page/index.tsx","components/print/index.tsx","components/edit/index.tsx","components/assemble/index.tsx","hooks.ts","components/nav/index.tsx","serviceWorker.ts","index.tsx","components/app/index.tsx","wrapper.ts","components/assemble/styles.module.css","components/nav/styles.module.css"],"names":["module","exports","Routes","MAX_PARTS","MIN_PARTS","PartInput","part","onChange","index","hex","TextField","e","target","value","name","label","PartPage","children","className","styles","page","numParts","useSecretFromLocation","location","useLocation","React","useMemo","state","Number","quorum","text","PrintSecret","history","useHistory","secret","parts","split","useShamir","useEffect","push","Edit","Fragment","noPrint","JSON","stringify","to","pathname","map","search","URLSearchParams","set","String","console","log","toString","destination","Assemble","href","window","protocol","host","createHref","key","renderAs","size","emptySecret","NewSecret","defaultState","useState","setState","handleChange","update","Object","assign","partsOptions","quorumOptions","i","onSubmit","preventDefault","Print","Paper","form","multiline","select","n","MenuItem","Button","type","color","variant","unreachable","_n","reducer","action","payload","initialState","usePartParameters","callback","query","get","isNaN","AssembleSecret","scanning","setScanning","setSecret","initialValue","item","localStorage","getItem","parse","error","storedValue","setStoredValue","valueToStore","Function","setItem","useLocalStorage","storage","setStorage","useReducer","dispatch","useCallback","replace","handleChangeHex","current","Array","fill","partInputs","assemble","join","values","reader","delay","onError","err","onScan","data","indexOf","onClick","Nav","nav","Tabs","event","Tab","Boolean","hostname","match","ReactDOM","render","basename","Container","maxWidth","CssBaseline","path","document","getElementById","secretBytes","TextEncoder","encode","uintParts","shamir","randomBytes","entries","uint","Buffer","from","reduce","obj","p","Uint8Array","utf8Decoder","TextDecoder","bytes","decode"],"mappings":"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","file":"static/js/main.b0d0b2d1.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"page\":\"styles_page__2ydav\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"qr\":\"styles_qr__3rz3I\",\"noPrint\":\"styles_noPrint__2Y233\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"form\":\"styles_form__2Hoej\",\"quorum\":\"styles_quorum__36Y8D\",\"parts\":\"styles_parts__3k7x6\"};","\nexport const MAX_PARTS = 10\nexport const MIN_PARTS = 2\n\nexport const DEFAULT_PARTS = 4\nexport const DEFAULT_QUORUM = 3\n\n\nexport enum Routes {\n  Edit = '/',\n  Print = '/print',\n  Assemble = '/assemble',\n}\n","import React from 'react'\nimport { TextField } from '@material-ui/core';\nimport { Part, MinimumPart } from '../../types'\n\ntype Props = {\n  part?: MinimumPart | Part,\n  onChange: (index: number, hex: string) => void,\n  index: number,\n}\n\nexport default function PartInput({ part, onChange, index }: Props) {\n  const hex = part?.hex ?? \"\"\n  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    onChange(index, e.target.value)\n  }\n\n  return (\n    <TextField\n      onChange={handleChange}\n      value={hex}\n      name=\"label\"\n      label={`Part ${index}`} />\n  )\n\n}\n","import React from 'react'\nimport { Part } from '../../types'\nimport PartInput from '../part-input'\nimport styles from './styles.module.css'\n\n\ntype Props = {\n  part: Part\n  children: React.ReactNode\n}\n\nexport default function PartPage({ part, children }: Props) {\n\n\n  return (\n    <div className={styles.page}>\n      <h1>{part.label}</h1>\n      <h2>{part.index} of {part.numParts}</h2>\n\n      {children}\n\n      <p>\n        If the QR code doesn't scan, you can type in the following:\n      </p>\n      <div>\n        <PartInput part={part}\n          onChange={() => { }}\n          index={part.index}\n        />\n      </div>\n    </div>\n  )\n}\n","import React from 'react'\nimport {\n  useLocation, useHistory, Link\n} from \"react-router-dom\";\nimport QRCode from 'qrcode.react'\nimport { Routes } from '../../constants'\nimport PartPage from '../part-page'\nimport { Secret } from '../../types'\nimport { split } from '../../wrapper'\nimport styles from './styles.module.css'\n\nexport function useSecretFromLocation(): Secret | null {\n  const location = useLocation()\n\n  return React.useMemo(() => {\n    if (!location.state) {\n      return null\n    }\n    const numParts = Number(location.state.numParts || 0)\n    const quorum = Number(location.state.quorum || 0)\n\n    if (!numParts || !quorum || quorum >= numParts) {\n      return null\n    }\n\n    return {\n      label: location.state.label || \"\",\n      text: location.state.text || \"\",\n      numParts,\n      quorum,\n    }\n  }, [location.state])\n}\n\n\nexport function useShamir(secret: Secret | null) {\n  return React.useMemo(() => {\n    if (secret == null) {\n      return\n    }\n    return split(secret)\n  }, [secret])\n}\n\nexport default function PrintSecret() {\n  const history = useHistory()\n  const secret = useSecretFromLocation()\n  const parts = useShamir(secret)\n\n\n  React.useEffect(() => {\n    if (\n      parts == null\n      || secret == null\n      || !secret.label\n      || !secret.text\n      || !secret.numParts\n      || !secret.quorum\n    ) {\n      history.push(Routes.Edit, secret)\n    }\n  }, [history, parts, secret])\n\n  if (parts == null) return null\n\n  return (\n    <React.Fragment>\n      <div className={styles.noPrint}>\n        <h1>Secret</h1>\n\n        <pre>{JSON.stringify(secret, null, 2)}</pre>\n        <Link to={{ pathname: Routes.Edit, state: secret }}>\n          Edit\n      </Link>\n\n      </div>\n      {parts.map((part) => {\n\n        const search = new URLSearchParams()\n        search.set('index', String(part.index))\n        search.set('hex', part.hex)\n        search.set('numParts', String(part.numParts))\n        search.set('quorum', String(part.quorum))\n        search.set('label', String(part.label))\n\n\n        // const label = query.get('label')\n\n        console.log('search', search.toString())\n\n        const destination: any = {\n          pathname: Routes.Assemble,\n          search: search.toString(),\n        }\n\n        const href = window.location.protocol + '//' + window.location.host\n          + history.createHref(destination)\n\n\n        return (\n          <PartPage part={part} key={part.index} >\n            <Link to={destination}>\n              <QRCode\n                renderAs=\"svg\"\n                size={512}\n                value={href}\n              />\n            </Link>\n          </PartPage>\n        )\n      }\n      )}\n\n    </React.Fragment>\n  )\n}\n","import React from 'react'\nimport { Paper, TextField, MenuItem, Button } from '@material-ui/core';\nimport { useHistory } from \"react-router-dom\";\nimport { Routes, MAX_PARTS, MIN_PARTS, DEFAULT_PARTS, DEFAULT_QUORUM } from '../../constants'\nimport { useSecretFromLocation } from '../print'\nimport { Secret } from '../../types'\nimport styles from './styles.module.css'\n\nconst emptySecret: Secret = {\n  label: \"\",\n  text: \"\",\n  numParts: DEFAULT_PARTS,\n  quorum: DEFAULT_QUORUM,\n}\n\n\nexport default function NewSecret() {\n  const history = useHistory()\n  const defaultState = useSecretFromLocation() || emptySecret\n\n  const [state, setState] = React.useState<Secret>(defaultState)\n\n  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {\n    const update = { [e.target.name]: e.target.value }\n    setState((state) => Object.assign({}, state, update))\n  }\n  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {\n    e.preventDefault()\n    history.push(Routes.Print, state)\n\n  }\n\n  const partsOptions: number[] = []\n  const quorumOptions: number[] = []\n  for (let i = 1; i <= MAX_PARTS; i++) {\n    if (i >= MIN_PARTS) {\n      partsOptions.push(i)\n    }\n    if (i < state.numParts) {\n      quorumOptions.push(i)\n    }\n  }\n\n  return (\n    <form onSubmit={handleSubmit} >\n      <Paper className={styles.form}>\n        <TextField\n          onChange={handleChange}\n          value={state.label}\n          name=\"label\"\n          label=\"Label\" />\n\n        <TextField\n          multiline={true}\n          label=\"Secret Text\"\n          onChange={handleChange}\n          value={state.text}\n          name=\"text\" />\n\n\n        <TextField\n          name=\"quorum\"\n          select\n          label=\"Quorum\"\n          value={state.quorum}\n          onChange={handleChange}\n        >\n          {quorumOptions.map((n) => (\n            <MenuItem key={n} value={n}>{n}</MenuItem>\n          ))}\n        </TextField>\n\n        <TextField\n          name=\"numParts\"\n          select\n          label=\"Parts\"\n          value={state.numParts}\n          onChange={handleChange}\n        >\n          {partsOptions.map((n) => (\n            <MenuItem key={n} value={n}>{n}</MenuItem>\n          ))}\n        </TextField>\n\n        <Button type=\"submit\" color=\"primary\" variant=\"outlined\">\n          Done\n        </Button>\n      </Paper>\n    </form>\n  )\n}\n","import React from 'react';\nimport QrReader from 'react-qr-reader'\nimport { useHistory } from 'react-router-dom'\nimport { Paper, TextField, MenuItem, Button } from '@material-ui/core';\nimport { Routes, MAX_PARTS, MIN_PARTS, DEFAULT_PARTS } from '../../constants'\nimport { useQuery, useLocalStorage } from '../../hooks'\nimport { Part, MinimumPart } from '../../types'\nimport { join } from '../../wrapper'\nimport styles from './styles.module.css'\nimport PartInput from '../part-input'\n\ntype State = {\n  numParts: number,\n  parts: Record<string, Part | MinimumPart>\n}\n\ntype ActionSetNumParts = {\n  type: 'setNumParts',\n  payload: number,\n}\n\ntype ActionsSetPart = {\n  type: 'setPart',\n  payload: MinimumPart | Part,\n}\n\ntype Action =\n  | ActionSetNumParts\n  | ActionsSetPart\n\nconst unreachable = (_n: never) => { }\nfunction reducer(state: State, action: Action): State {\n\n  switch (action.type) {\n    case \"setNumParts\":\n      return {\n        ...state,\n        numParts: action.payload,\n        parts: {},\n      }\n    case \"setPart\": {\n      const part = action.payload\n      const numParts = 'numParts' in part ? part.numParts : state.numParts\n      let parts = state.parts\n      if (numParts !== state.numParts) {\n        parts = {}\n      }\n\n      return {\n        ...state,\n        parts: {\n          ...parts,\n          [part.index]: part\n        },\n        numParts,\n      }\n    }\n    default:\n      unreachable(action)\n  }\n\n  return state\n}\n\nconst initialState: State = {\n  numParts: DEFAULT_PARTS,\n  parts: {},\n}\n\nfunction usePartParameters(callback: (p: Part) => void) {\n  const query = useQuery()\n\n  const index = Number(query.get('index'))\n  const hex = query.get('hex')\n  const numParts = Number(query.get('numParts'))\n  const label = query.get('label')\n  const quorum = Number(query.get('quorum'))\n  React.useEffect(() => {\n\n    console.log({\n\n      index,\n      hex,\n      numParts,\n      label,\n      quorum,\n\n    })\n\n    if (\n      !isNaN(index)\n      && index > 0\n      && hex\n      && !isNaN(numParts)\n      && numParts > 0\n      && !isNaN(quorum)\n      && quorum > 0\n      && label != null\n    ) {\n      const part: Part = {\n        index,\n        hex,\n        label,\n        numParts,\n        quorum\n      }\n      console.log('query part', part)\n      callback(part)\n    }\n  }, [callback, hex, index, label, numParts, quorum])\n}\n\nexport default function AssembleSecret() {\n  const history = useHistory()\n  const [scanning, setScanning] = React.useState(false)\n  const [secret, setSecret] = React.useState<null | string>(null)\n\n  // I couldn't figure out the types to extract this into its own hook\n  /* useStorageReducer(key, reducer, initialState) */\n  const [storage, setStorage] = useLocalStorage('state', initialState)\n  const [state, dispatch] = React.useReducer(reducer, storage)\n  React.useEffect(() => {\n    if (storage !== state) {\n      setStorage(state)\n    } else {\n    }\n  }, [setStorage, state, storage])\n\n\n  const paramCB = React.useCallback((part) => {\n    dispatch({\n      type: 'setPart',\n      payload: part,\n    })\n    history.replace(Routes.Assemble)\n  }, [history])\n  usePartParameters(paramCB)\n\n  const { numParts, parts } = state\n  const handleChangeNumParts = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {\n    dispatch({\n      type: 'setNumParts',\n      payload: Number(e.target.value)\n    })\n  }\n\n  const handleChangeHex = (index: number, hex: string) => {\n    const current = parts[index] ?? { index, hex: '' }\n    dispatch({\n      type: 'setPart',\n      payload: {\n        ...current,\n        hex\n      }\n    })\n  }\n\n  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {\n    e.preventDefault()\n\n    try {\n      const secret = join(\n        Object.values(parts)\n      )\n      setSecret(secret)\n    } catch (e) {\n      console.error(e)\n    }\n  }\n\n  const handleScanError = (err: any) => {\n    console.error(err)\n  }\n  const handleScan = (data: string | null) => {\n    console.log('scan', data)\n    if (data) {\n      const href = window.location.protocol + '//' + window.location.host\n        + history.createHref({ pathname: '/' })\n      if (data.indexOf(href) === 0) {\n        history.replace(data.replace(href, ''))\n      }\n    }\n  }\n\n  const partsOptions = new Array(MAX_PARTS - MIN_PARTS)\n    .fill(0)\n    .map((_n, index) => (\n      <MenuItem key={index} value={index + MIN_PARTS}>{index + MIN_PARTS}</MenuItem>\n    ))\n\n  const partInputs: JSX.Element[] = []\n  for (let i = 1; i <= numParts; i++) {\n    partInputs.push(\n      <PartInput key={i} index={i} part={parts[i]} onChange={handleChangeHex} />\n    )\n  }\n  if (secret) {\n\n    return (\n      <Paper className={styles.assemble}>\n        {secret}\n      </Paper>\n    )\n\n  }\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <Paper className={styles.assemble}>\n        {scanning ? (\n          <QrReader\n            className={styles.reader}\n            delay={500}\n            onError={handleScanError}\n            onScan={handleScan}\n          />\n        ) : (\n            <Button variant=\"outlined\" onClick={() => setScanning(true)}>Scan QR Codes</Button>\n          )}\n\n        <br />\n\n        <TextField\n          name=\"numParts\"\n          select\n          label=\"Parts\"\n          value={numParts}\n          onChange={handleChangeNumParts}\n        >\n          {partsOptions}\n        </TextField>\n\n        {partInputs}\n\n        <Button type=\"submit\" color=\"primary\" variant=\"outlined\">\n          Done\n        </Button>\n\n        {secret && (\n          <div>\n            Secret: {secret}\n          </div>\n        )}\n\n      </Paper>\n    </form>\n  )\n}\n","import React from 'react'\nimport { useLocation } from 'react-router-dom'\n\nexport function useHtmlId() {\n  const id = React.useMemo(() => Math.random().toString(16).substr(2), [])\n\n  return (name: string) => name + '-' + id\n}\n\n\nexport function useQuery() {\n  return new URLSearchParams(useLocation().search);\n}\n\n\n\n// Based on the hook at https://usehooks.com/useLocalStorage/\nexport function useLocalStorage<T>(key: string, initialValue: T): [T, React.Dispatch<React.SetStateAction<T>>] {\n  // State to store our value\n  // Pass initial state function to useState so logic is only executed once\n  const [storedValue, setStoredValue] = React.useState<T>(() => {\n    try {\n      // Get from local storage by key\n      const item = window.localStorage.getItem(key);\n      // Parse stored json or if none return initialValue\n      return item ? JSON.parse(item) : initialValue;\n    } catch (error) {\n      // If error also return initialValue\n      console.log(error);\n      return initialValue;\n    }\n  });\n\n  // Return a wrapped version of useState's setter function that ...\n  // ... persists the new value to localStorage.\n  const setValue: React.Dispatch<React.SetStateAction<T>> = (value) => {\n    try {\n      // Allow value to be a function so we have same API as useState\n      const valueToStore =\n        value instanceof Function ? value(storedValue) : value;\n      // Save state\n      setStoredValue(valueToStore);\n      // Save to local storage\n      window.localStorage.setItem(key, JSON.stringify(valueToStore));\n    } catch (error) {\n      // A more advanced implementation would handle the error case\n      console.log(error);\n    }\n  };\n\n  return [storedValue, setValue];\n}\n","import React from 'react'\nimport { Tabs, Tab } from '@material-ui/core'\nimport { Routes } from '../../constants'\nimport { useHistory, useLocation } from 'react-router-dom'\nimport styles from './styles.module.css'\n\nconsole.log('nav', styles)\n\nexport default function Nav() {\n  const location = useLocation()\n  const history = useHistory()\n\n  const handleChange = (event: any, pathname: string) => {\n    history.push(pathname)\n  }\n\n  return (\n    <nav className={styles.nav}>\n      <Tabs\n        value={location.pathname}\n        onChange={handleChange}\n      >\n        <Tab value={Routes.Edit} label=\"New Secret\" />\n        <Tab value={Routes.Assemble} label=\"Assemble Secret\" />\n      </Tabs>\n    </nav >\n  )\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/app';\nimport { BrowserRouter as Router } from \"react-router-dom\";\nimport './serviceWorker';\n\nconst basename = '/shamir-secret-splitter'\n\nReactDOM.render(<Router basename={basename}><App /></Router>, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\n// serviceWorker.unregister();\n","import React from 'react';\nimport {\n  Switch,\n  Route,\n} from \"react-router-dom\";\nimport { CssBaseline, Container } from '@material-ui/core';\nimport { Routes } from '../../constants'\nimport Edit from '../edit'\nimport Print from '../print'\nimport AssembleSecret from '../assemble'\nimport Nav from '../nav'\n\nexport default function App() {\n  return (\n    <Container maxWidth=\"sm\">\n      <CssBaseline />\n      <Nav />\n      <Switch>\n        <Route path={Routes.Print}>\n          <Print />\n        </Route>\n        <Route path={Routes.Assemble}>\n          <AssembleSecret />\n        </Route>\n        <Route path={Routes.Edit}>\n          <Edit />\n        </Route>\n      </Switch>\n    </Container>\n  );\n}\n","import * as shamir from 'shamir'\nimport { randomBytes } from 'crypto'\nimport { Secret, Part, MinimumPart } from './types'\n\nexport function split(secret: Secret): Part[] {\n  const utf8Encoder = new TextEncoder();\n  let secretBytes = utf8Encoder.encode(secret.text);\n\n  const uintParts = shamir.split(randomBytes, secret.numParts, secret.quorum, secretBytes);\n\n  return Object.entries(uintParts).map(([key, uint]): Part => {\n    return {\n      label: secret.label,\n      numParts: secret.numParts,\n      quorum: secret.quorum,\n      index: Number(key),\n      hex: Buffer.from(uint).toString('hex')\n    }\n  })\n}\n\nexport function join(parts: MinimumPart[]): Secret['text'] {\n  const uintParts = parts\n    .reduce((obj, p) => {\n      obj[p.index] = Uint8Array.from(Buffer.from(p.hex, 'hex'))\n      return obj\n    }, {} as Record<string, Uint8Array>)\n  const utf8Decoder = new TextDecoder();\n\n  const bytes = shamir.join(uintParts)\n\n  return utf8Decoder.decode(bytes)\n}\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"assemble\":\"styles_assemble__1ky0g\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"nav\":\"styles_nav__2cd2r\"};"],"sourceRoot":""}